/**
 * sbus-gateway
 * Copyright(c) 2018 Process and Plant Automation Limited
 * Written by: Fiifi Asante-Antwi
 * Credits: coming soon
 * MIT Licensed
 */

//'use strict';

// const sbusLib = require("./sbus");
const sbusLib = require('./sbus');

//udp server
const dgram = require('dgram');
const server = dgram.createSocket('udp4');

//events emitter
const EventEmitter = require('events');
class classEmitter extends EventEmitter {}
const sbusEmitter = new classEmitter();

const models = require("./../../../src/users/models")
var intents = require("./../../../src/users/intents")
intents = intents.intents;

User = models.User;
RSIP = models.RSIP;
Relay = models.Relay;
RelayChannel = models.RelayChannel; 
Command = models.Command;

//set the udp server and events emitter used by the sbus library
sbusLib.SetObjects(server, sbusEmitter);

server.on('error', err => {
  //console.log(`server error:\n${err.stack}`);
  //server.close();
});




server.on("message",function(msg,rinfo){
  console.log(msg);
  console.log(rinfo);
  // get the IP address of incoming data
  var incoming_ipaddress = rinfo.address;
  var incoming_port_number = rinfo.port; 
  console.log(`Got ${msg} from ${incoming_ipaddress}:${incoming_port_number}`);
  console.log(rinfo);

  // get the raw message coming 
  var myBuffer = msg;
  var raw_message =[];
  for (let i=0;i<myBuffer.length;i++){
    raw_message.push(myBuffer[i]);
    }
    console.log("********************************************");
    console.log("############################################");
    console.log(raw_message);
  try{
    var current_optcode = raw_message.slice(21,23); 
    if (JSON.stringify(current_optcode)==JSON.stringify([240,4])){
      // this is a mac address response.Check DB
      // get the mac address 
      var incoming_macaddress = raw_message.slice(25,33).join(":");
      console.log(`incoming macaddress is ${incoming_macaddress}`);

        Command.findOne({where:{"macaddress":incoming_macaddress}}).then(function(command){ 
      //console.log(command);
      //res.send(command);  
      // get the user row with this command's email
      User.findAll({where:{"username":command.email}}).then(function(user){
        //res.send(user);
        // get relays of this user
        user = user[0];
        var b=[];
        Relay.findAll({where:{"UserId":user.id},include:[{model:RelayChannel}]}).then(function(relays){                       
        //res.send(relays);
        var c = relays.forEach(function(x){
          // x is one relay 
          // one relay can have multiple channels 
          // find the channel which has this name 
          //console.log(x["RelayChannels"].length)
          if (x["RelayChannels"].length!=0){
            // console.log(x["RelayChannels"].length);
            //res.send("hi")
            x["RelayChannels"].forEach(function(y){
              //console.log(y["name"]);
              if (y["name"]==command.location){
                //b.push([y["name"],y["channel_number"],y["relayId"]])
                if (command.intent=="LightOn"){
                  var level = 100;
                }
                else if (command.intent=="LightOff"){
                    var level = 0;
                }
                b.push({
                  "ip address":incoming_ipaddress,
                  "port number":incoming_port_number,
                  "subnet id of relay":x["subnetId"],
                  "device id of relay":x["deviceId"],
                  "channel id of relay":y["channel_number"],
                  "name of channel":y["name"],
                  "level":level,
                  "intent":command.intent
                })
                console.log(b);

              }

            })
          }

        });
        // delete command with this mac address       
        Command.destroy({where:{
          "macaddress":incoming_macaddress,
          "id":command.id
        }}).then(function(command){          
          // command.forEach(function(x){
          //  sbusLib.LightingControl(subnetId, deviceId,channel, 0, 0,x["ip address"],x["port number"]);
          // })

          // console.log(b);
          //res.send(b);
          //sbusLib.sbus.processData(msg);  
          b=b[0];
          sbusLib.sbus.lighting(
              b["subnet id of relay"],
              b["device id of relay"],
              b["channel id of relay"],
              b["level"],
              0,
              b["ip address"],
              b["port number"]

            )

        })
        

      })


    })
  }).catch(function(err){
    console.log(err)
    //throw err;
  })
      // We assume a certain user has this mac address.Else we're fucked

    }else{
      sbusLib.sbus.ReadMacAddress(1,100,incoming_port_number,incoming_ipaddress);
    }

  }catch(err){
    console.log(err);
    //sbusLib.sbus.ReadMacAddress(1,100,incoming_port_number,incoming_ipaddress); //subnetId deviceId
  }




})

server.on('listening', () => {
  //const address = server.address();
  //console.log(`server listening ${address.address}:${address.port}`);
  server.setBroadcast(true);
});

sbusEmitter.on('error', err => {
  //console.log(`server error:\n${err.stack}`);
});

//exports
module.exports.server = server;
module.exports.eventsEmitter = sbusEmitter;
module.exports.sbus = sbusLib.sbus;
