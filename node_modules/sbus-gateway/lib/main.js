    /**
 * sbus-gateway
 * Copyright(c) 2018 Process and Plant Automation Limited
 * Written by: Fiifi Asante-Antwi
 * Credits: coming soon
 * MIT Licensed
 */

'use strict';

const sbusLib = require("./udp_server");
let statusUpdateInterval = 1000;
var deviceTypes = {};
let periodictimer;
let scheduledtimer;
module.exports = {

    Initialize: function (statusUpdateConfig, sbusDeviceTypes) {
        deviceTypes = sbusDeviceTypes;
        let ipaddress = statusUpdateConfig.ipAddress;
        try{sbusLib.sbus.destinationIPs=statusUpdateConfig.destinationIPs}catch(e){}

        if (statusUpdateConfig != null){
            sbusLib.sbus.statusUpdateConfig = statusUpdateConfig;

            if (sbusLib.sbus.statusUpdateConfig.poll_Interval != null){
                statusUpdateInterval = sbusLib.sbus.statusUpdateConfig.poll_Interval;
                if (isNaN(statusUpdateInterval)||statusUpdateInterval < 100) statusUpdateInterval = 1000; 
                else if (statusUpdateInterval > 60000) statusUpdateInterval = 60000; //1hr
                else{statusUpdateInterval = sbusLib.sbus.statusUpdateConfig.poll_Interval;}
            }
        }
        
        if (ipaddress != null){sbusLib.server.bind(6000, ipaddress);}
        else{sbusLib.server.bind(6000);}

        setTimeout(() => {
            this.scheduledtimer = setInterval(GetStatusUpdate, statusUpdateInterval);
            this.periodictimer = setInterval(periodicUpdate, 20000);
        }, 5000);
        
    },
    Update: function (statusUpdateConfig, sbusDeviceTypes) {
        try{
            clearInterval(this.periodictimer);
            clearInterval(this.scheduledtimer);
        }catch(err){}
        deviceTypes = sbusDeviceTypes;

        if (statusUpdateConfig != null){
            sbusLib.sbus.statusUpdateConfig = statusUpdateConfig;

            if (sbusLib.sbus.statusUpdateConfig.poll_Interval != null){
                statusUpdateInterval = sbusLib.sbus.statusUpdateConfig.poll_Interval;
                if (isNaN(statusUpdateInterval)||statusUpdateInterval < 100) statusUpdateInterval = 1000; 
                else if (statusUpdateInterval > 60000) statusUpdateInterval = 60000; //1hr
                else{statusUpdateInterval = sbusLib.sbus.statusUpdateConfig.poll_Interval;}
            }
        }
        
        setTimeout(() => {
            this.scheduledtimer = setInterval(GetStatusUpdate, statusUpdateInterval);
            this.periodictimer = setInterval(periodicUpdate, 20000);
        }, 5000);
        
    },
    StatusUpdateConfig: function (statusUpdateConfig) {
        if (statusUpdateConfig != null)
            sbusLib.sbus.statusUpdateConfig = statusUpdateConfig;
    },

    Server: function(){
        return sbusLib.server;
    },

    Events: function(){
        return sbusLib.eventsEmitter;
    },

    LightingControl: function (subnetid, deviceid, channel, level, time) {
        sbusLib.sbus.lighting(subnetid, deviceid, channel, level, time);
        },

    RelayStatus: function (subnetid, deviceid) {
        sbusLib.sbus.statusRelay(subnetid, deviceid);
        },

    Status4Z: function (subnetid, deviceid) {
        sbusLib.sbus.status4Z(subnetid, deviceid);
        },
        GETMAC: function (subnetid, deviceid) {
        sbusLib.sbus.GETMAC(subnetid, deviceid);
        },
    PlayRadio: function(subnetid, deviceid){
		sbusLib.sbus.audiocontrol(subnetid, deviceid,1,4,0,0);		// Choose Music source FM Radio first.
		sbusLib.sbus.audiocontrol(subnetid, deviceid,4,3,0,0);		// Play Control -> Play
	    },
    PlayAUX: function(subnetid, deviceid){
		sbusLib.sbus.audiocontrol(subnetid, deviceid,1,2,0,0);		// Choose Music source FM Radio first.
		//sbus.audiocontrol(subnetid, deviceid4,3,0,0);		// Play Control -> Play
        },
    PlaySD: function(subnetid, deviceid){
		sbusLib.sbus.audiocontrol(subnetid, deviceid,1,1,0,0);		// Choose Music source FM Radio first.
		//sbusLib.sbus.audiocontrol(subnetid, deviceid,4,3,0,0);		// Play Control -> Play
        },
    PlaySDsong: function(subnetid, deviceid){
		//sbusLib.sbus.audiocontrol(subnetid, deviceid,1,1,0,0);		// Choose Music source FM Radio first.
		sbusLib.sbus.audiocontrol(subnetid, deviceid,4,3,0,0);		// Play Control -> Play
        },
    PlayFTP: function(subnetid, deviceid){
		sbusLib.sbus.audiocontrol(subnetid, deviceid,1,3,0,0);		// Choose Music source FM Radio first.
		//sbus.audiocontrol(subnetid, deviceid4,3,0,0);		// Play Control -> Play
        },

    PreviousAlbum: function(subnetid, deviceid){
		sbusLib.sbus.audiocontrol(subnetid, deviceid,3,1,0,0);		// Choose Previous Album.
	    },
	
	NextAlbum: function(subnetid, deviceid){
		sbusLib.sbus.audiocontrol(subnetid, deviceid,3,2,0,0);		// Choose Next Album.
        },

    SelectAlbum: function(subnetid, deviceid,number){
		sbusLib.sbus.audiocontrol(subnetid, deviceid,3,3,number,0);		// Choose Next Album.
	    },
	
	PreviousRadioCh: function(subnetid, deviceid){
		sbusLib.sbus.audiocontrol(subnetid, deviceid,3,4,0,0);		// Choose Previous Radio Channel.
	    },
	
	NextRadioCh: function(subnetid, deviceid){
		sbusLib.sbus.audiocontrol(subnetid, deviceid,3,5,0,0);		// Choose Next Radio Channel.
	    },
	
	NextSelectRadioCh: function(subnetid, deviceid,channel){
		sbusLib.sbus.audiocontrol(subnetid, deviceid,3,6,channel,0);		// Choose Next Album.
        },

    VolumeUp: function(subnetid, deviceid){
		
		sbusLib.sbus.audiocontrol(subnetid, deviceid,5,1,2,0);	
	    },
	
	VolumeDown: function(subnetid, deviceid){
		sbusLib.sbus.audiocontrol(subnetid, deviceid,5,1,1,0);	
        },

    VolumeBassUp: function(subnetid,deviceid,level){		
		sbusLib.sbus.audiocontrol(5,3,2,level);
	    },
	
	VolumeBassDown: function(subnetid,deviceid,level){		
		sbusLib.sbus.audiocontrol(5,3,1,level);
	    },
	
	VolumeTrebleUp: function(subnetid,deviceid,level){
		sbusLib.sbus.audiocontrol(5,2,2,level);
	    },
	
	VolumeTrebleDown: function(subnetid,deviceid,level){
		sbusLib.sbus.audiocontrol(5,2,1,level);
        },
    
	UniversalSwitch: function(subnetid,deviceid,switchNo,status){
		sbusLib.sbus.universalSwitch(subnetid,deviceid,switchNo,status);
        },
        
	CheckUniversalSwitch: function(subnetid,deviceid){
		sbusLib.sbus.checkUniversalSwitch(subnetid,deviceid);
        },
        
    GetZoneStatus: function(subnetid,deviceid){
		sbusLib.sbus.GetZoneStatus(subnetid, deviceid);		// Choose Next Album.
        },

    PreviousTrack: function(subnetid,deviceid){
		sbusLib.sbus.previousTrack(subnetid, deviceid);		// Choose Next Album.
        },

    NextTrack: function(subnetid,deviceid){
		sbusLib.sbus.nextTrack(subnetid, deviceid);		// Choose Next Album.
        },

    Stop: function(subnetid,deviceid){
        sbusLib.sbus.stop(subnetid, deviceid);
        },

    Volume: function(subnetid,deviceid,level){
        level = 79-((((level)/100)*79).toFixed(0))
        sbusLib.sbus.volume(subnetid, deviceid,level);	
        },

    RGBW: function(subnetid, deviceid, red, green, blue,white, runtime){
    
        sbusLib.sbus.rgbw(subnetid, deviceid, red, green, blue,white, runtime)
        },

    LED_SingleAdj: function(subnetid,deviceid,loopNo,loopLevel){
        sbusLib.sbus.LED_singleAdj(subnetid, deviceid, loopNo,loopLevel)
        }
         
    
}

function periodicUpdate(){
    if (sbusLib.sbus.statusUpdateConfig.modbusConfig.devices !== null) {
        for (let device of sbusLib.sbus.statusUpdateConfig.modbusConfig.devices) {
            if(deviceTypes.relayTypes.indexOf(device.deviceType)>-1){
                module.exports.RelayStatus(device.subnetid,device.deviceid);
            }
            else if(deviceTypes.sensorTypes.indexOf(device.deviceType)>-1){
                module.exports.CheckUniversalSwitch(device.subnetid,device.deviceid);
            }
            else if(device.deviceType=="4Z"){
                module.exports.Status4Z(device.subnetid,device.deviceid);
            }
        }
    }
    
}

function GetStatusUpdate()
{
    // console.log(sbusLib.sbus.statusUpdateConfig.modbusConfig.devices)
    if (sbusLib.sbus.statusUpdateConfig != null) {
        try {
            
            if (sbusLib.sbus.statusUpdateConfig.modbusConfig.devices !== null) {

                for (let device of sbusLib.sbus.statusUpdateConfig.modbusConfig.devices) {
                    //relay status
                    if(deviceTypes.relayTypes.indexOf(device.deviceType)>-1&&device.poll){
                        module.exports.RelayStatus(device.subnetid, device.deviceid);
                    }
                    //4Z status
                    else if(device.deviceType=="4Z"&&device.poll){
                        module.exports.Status4Z(device.subnetid, device.deviceid);
                    }
                    else{}

                }
            }
            
        }
        catch (err){}
    }

    //schedule next status update
    
}
