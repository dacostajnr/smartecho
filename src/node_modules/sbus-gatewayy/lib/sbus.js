/**
 * sbus-gateway
 * Copyright(c) 2018 Process and Plant Automation Limited
 * Written by: Fiifi Asante-Antwi
 * Credits: coming soon
 * MIT Licensed
 */

'use strict';

var udpServer = null;
var eventsEmitter = null;

var sbus = {

    // ===================================================================================================
    // Global Settings and Variables. Initialize the global variables.
    // ===================================================================================================
    SysName: "SmartHome",

    // ===================================================================================================
    // SMART-BUS UDP Protocol = Source IP + UDP Package Head + Protocol Base Structure (all in hex format)
    //						  =   Part 1  +     Part 2       +                 Part 3
    // ===================================================================================================
    sourceIP: "\xFF\xFF\xFF\xFF",									// Part 1 : 255.255.255.255
    udpHeader: "\x53\x4D\x41\x52\x54\x43\x4C\x4F\x55\x44",			// Part 2 : SMARTCLOUD in hex
    destinationIPs: ["255.255.255.255"],

    // Part 3 The breakdown of the Protocol Base Structure
    startcode: "\xAA\xAA",											// Starting symbol. Fixed format of \xAAAA. Not included in checksum calculation. (2 bytes)
    lengthdata: "\x0F",											    // Total number of bytes for data package. Counted from third byte onwards inclusive of crc for checksum.(1 byte)
    deviceSubnetID: "\xBB",										    // Address of the device sending the data package : Subnet ID (1 byte)
    senderDeviceID: "\xBB",										    // Address of the device sending the data package : Device ID (1 byte)
    senderDeviceType: "\xDD\xDD",									// Type of original device.(2 bytes)
    //Operation Code  												// Operation code.(2 bytes)
    //TargetSubnetID 				 								// Target Subnet ID. (1 byte)
    //TargetDeviceID  										 		// Target Device ID. (1 byte)
    //Additional content											// Other additionial parameters if needed. (No. of bytes depends on the different commands)
    //CRC Checksum String.fromCharCode(area);						// CRC checksum (2 bytes)

    // ===================================================================================================
    //Other Configuration
    statusUpdateConfig: null,                                       // Array of devices to be polled for status. JSON array format
    //Regex for retrieving status information from modules

    rgx2ChannelStatus: /\xAA\xAA(.)(.)(.)(.)(.)\x00\x34(.)(.)(.)(.)(.)(.)(.)/i,									                                    // 2 channels. Relay/Dimmer.
    rgx3ChannelStatus: /\xAA\xAA(.)(.)(.)(.)(.)\x00\x34(.)(.)(.)(.)(.)(.)(.)(.)/i,									                                // 3 channels. Relay only.
    rgx4ChannelStatus: /\xAA\xAA(.)(.)(.)(.)(.)\x00\x34(.)(.)(.)(.)(.)(.)(.)(.)(.)/i,								                                // 4 channels. Relay/Dimmer.
    rgx6ChannelStatus: /\xAA\xAA(.)(.)(.)(.)(.)\x00\x34(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)/i,						                                    // 6 channels. Relay/Dimmer.
    rgx8ChannelStatus: /\xAA\xAA(.)(.)(.)(.)(.)\x00\x34(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)/i,					                                // 8 channels. Dimmer only.
    rgx12ChannelStatus: /\xAA\xAA(.)(.)(.)(.)(.)\x00\x34(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)/i,		                                // 12 channels. Relay only.
    rgx15ChannelStatus: /\xAA\xAA(.)(.)(.)(.)(.)\x00\x34(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)/i,		                        // 23 zone mix
    rgx24ChannelStatus: /\xAA\xAA(.)(.)(.)(.)(.)\x00\x34(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)/i,  //
    rgx15ChannelStatusB: /\xAA\xAA(.)(.)(.)(.)(.)\xEF\xFF(.)(.)(.)(.)(.)(.)(.)(.)(.)/i,
    //15 CHANNEL RELAY
    rgxZoneAudioStatusON: /\xAA\xAA(.)(.)(.)(.)(.)\x19\x2F(.)(.)#Z(.*),(.*),SRC(.*),VOL(.*)\x0D(.*)/i,

    relaystate: /\xAA\xAA(.)(.)(.)(.)(.)\xEF\xFF(.)(.)(.)(.)(.)(.)(.)(.)/i,

    relayresposnse: /\xAA\xAA(.)(.)(.)(.)(.)\x00\x32(.)(.)(.)(.)(.)(.)(.)(.)(.)/i,

    Status4Z: /\xAA\xAA(.)(.)(.)(.)(.)\x01\x2D(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)/i,

    broadcast4Z: /\xAA\xAA(.)(.)(.)(.)(.)\xDC\x22(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)/i,

    SensorBaseStatus: /\xAA\xAA(.)(.)(.)(.)(.)\xD9\x95(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)/i,                                                      // 4Z

    // function to calculate and check the CRC verification codes
    csumCode: function (csumString,ip=null,port=null) {
        
        var frame = Buffer.from(csumString, "ASCII");
        var crc = sbus.PackCRC_Ex(frame, 0, frame.length - 1);

        var toSend = sbus.sourceIP + sbus.udpHeader + "\xAA\xAA" + csumString + String.fromCharCode(crc[0]) + String.fromCharCode(crc[1]);
        var data = Buffer.from(toSend, "ASCII");
        // console.log(csumString,data,toSend)
        // console.log("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^");
        // console.log(data);
        // console.log(ip);
        // console.log(port);
        // console.log("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^");

        if ((ip!=null) && (ip!=null)){
            console.log("csum calling");
            sbus.sendFinalMessage(data,ip,1234);
        }

        // try {

        // for(let address of sbus.destinationIPs){
        //     udpServer.send(data, 0, data.length, 6000, address, function (error) {
        //         if (error) {

        //             return false;
        //         } else {
        //             return true;
        //         }
        //     });
        // }
        // }
        // catch (err) {

        // }
    },
    sendFinalMessage:function(data,ip,port){
        try{
            udpServer.send(data, 0, data.length, port, ip, function (error) {
                if (error) {

                    return false;
                } else {
                    return true;
                }
            });
        }catch(err){console.log(err)}
    },
    test:function(data){
        console.log(data);
    },

    formatStringHeader: function(lengthdata, operationCode, targetSubnetID, targetDeviceID){
        var targetSubnetID = String.fromCharCode(targetSubnetID);		                // Target Subnet ID.
        var targetDeviceID = String.fromCharCode(targetDeviceID);  // Target Device ID.
        var rtSting =  lengthdata + "\xBB"+"\xBB"+"\xDD\xDD" + operationCode + targetSubnetID + targetDeviceID;
        return rtSting;
    },

    //function to calculate CRC
    PackCRC_Ex: function (arrayBuf, pStartIndex, pStopIndex) {
        var crc = new Array(2);

        var CRCTable = [
            0, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7, 0x8108, 0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef,
            0x1231, 0x210, 0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6, 0x9339, 0x8318, 0xb37b, 0xa35a, 0xd3bd, 0xc39c, 0xf3ff, 0xe3de,
            0x2462, 0x3443, 0x420, 0x1401, 0x64e6, 0x74c7, 0x44a4, 0x5485, 0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee, 0xf5cf, 0xc5ac, 0xd58d,
            0x3653, 0x2672, 0x1611, 0x630, 0x76d7, 0x66f6, 0x5695, 0x46b4, 0xb75b, 0xa77a, 0x9719, 0x8738, 0xf7df, 0xe7fe, 0xd79d, 0xc7bc,
            0x48c4, 0x58e5, 0x6886, 0x78a7, 0x840, 0x1861, 0x2802, 0x3823, 0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a, 0xb92b,
            0x5af5, 0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0xa50, 0x3a33, 0x2a12, 0xdbfd, 0xcbdc, 0xfbbf, 0xeb9e, 0x9b79, 0x8b58, 0xbb3b, 0xab1a,
            0x6ca6, 0x7c87, 0x4ce4, 0x5cc5, 0x2c22, 0x3c03, 0xc60, 0x1c41, 0xedae, 0xfd8f, 0xcdec, 0xddcd, 0xad2a, 0xbd0b, 0x8d68, 0x9d49,
            0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13, 0x2e32, 0x1e51, 0xe70, 0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a, 0x9f59, 0x8f78,
            0x9188, 0x81a9, 0xb1ca, 0xa1eb, 0xd10c, 0xc12d, 0xf14e, 0xe16f, 0x1080, 0xa1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067,
            0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c, 0xe37f, 0xf35e, 0x2b1, 0x1290, 0x22f3, 0x32d2, 0x4235, 0x5214, 0x6277, 0x7256,
            0xb5ea, 0xa5cb, 0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d, 0x34e2, 0x24c3, 0x14a0, 0x481, 0x7466, 0x6447, 0x5424, 0x4405,
            0xa7db, 0xb7fa, 0x8799, 0x97b8, 0xe75f, 0xf77e, 0xc71d, 0xd73c, 0x26d3, 0x36f2, 0x691, 0x16b0, 0x6657, 0x7676, 0x4615, 0x5634,
            0xd94c, 0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9, 0xb98a, 0xa9ab, 0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x8e1, 0x3882, 0x28a3,
            0xcb7d, 0xdb5c, 0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a, 0x4a75, 0x5a54, 0x6a37, 0x7a16, 0xaf1, 0x1ad0, 0x2ab3, 0x3a92,
            0xfd2e, 0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b, 0x9de8, 0x8dc9, 0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0xcc1,
            0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8, 0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0xed1, 0x1ef0
        ];


        var shortLenOfBuf = (pStopIndex - pStartIndex + 1);

        try {
            var num = 0;
            var index = pStartIndex;
            var num3 = 0;
            var num4 = 0;
            while (shortLenOfBuf != 0) {

                num3 = (num >> 8) & 0xff;
                num = (num << 8);
                num4 = (num3 ^ arrayBuf[index]) & 0xff;
                num = (num ^ CRCTable[num4 & 0xff]);
                index = (index + 1);
                shortLenOfBuf = (shortLenOfBuf - 1);
            }

            crc[0] = (num >> 8) & 0xff;
            crc[1] = (num & 0xff);
        }
        catch (Exception) {
        }

        return crc;
    },


    //function to convert from byte array to string
    pack: function (bytes) {
        var s = "";
        for (var i = 0; i < bytes.length; i++)
            s += String.fromCharCode(bytes[i]);
        return s;
    },

    lighting: function (subnetid, deviceid, channel, level, time,ip,port) {
        console.log("i got you bro")

        // Sample Command : \xAA\xAA \x0F \xBB \xBB \xDD\xDD \x00\x31 \subnetid\deviceid \channel \level \highruntime \lowruntime \crc\crc
        // Sample string : "\x0F\xBB\xBB\xDD\xDD\x00\x31\x01\x02\x01\x64\x00\x00";
        

       var channelhex = String.fromCharCode(channel);						// Lighting channel number, from 1-255. if 255 means broadcast channel of the device.
       var levelhex = String.fromCharCode(level);							// Lighting brightness level, from 0-100%. On=\x00, Off=\x64
       var hightime = String.fromCharCode((time >> 8) & 0xFF);				// High 8 bits running time. 0 - 3600s.
       var lowtime = String.fromCharCode(time & 0xFF);                     // Low 8 bits running time. 0 - 3600s.
       var string = sbus.formatStringHeader("\x0F","\x00\x31",subnetid,deviceid) +
           channelhex + levelhex + hightime + lowtime;
       sbus.csumCode(string,ip,port);
    },

    statusRelay: function (subnetid, deviceid) {
        // Sample Command : \xAA\xAA \x0B \xBB\xBB\xDD\xDD \x00\x33 \subnetid\deviceid \crc\crc
        // Sample string : "\x0B\xBB\xBB\xDD\xDD\x00\x33\x01\x02";
        var string = sbus.formatStringHeader("\x0B","\x00\x33",subnetid,deviceid);
        sbus.csumCode(string);
    },

    status4Z: function (subnetid, deviceid) {
        var addContent = String.fromCharCode(0);
        var string = sbus.formatStringHeader("\x0C","\x01\x2C",subnetid,deviceid) + addContent;
        sbus.csumCode(string);
    },
    GETMAC: function (subnetid, deviceid) {
      
        var string = sbus.formatStringHeader("\x0B","\xF0\x03",subnetid,deviceid)
        sbus.csumCode(string);
        
    },

    audiocontrol: function (subnetid, deviceid, controltype, para1, para2, para3) {
        var ctypehex = String.fromCharCode(controltype);					// Zone code.
        var para1hex = String.fromCharCode(para1);							// Mode code.
        var para2hex = String.fromCharCode(para2);							// Mode code.
        var para3hex = String.fromCharCode(para3);							// Mode code.
        var string = sbus.formatStringHeader("\x0F","\x02\x18",subnetid,deviceid)
            + ctypehex + para1hex + para2hex + para3hex;
        sbus.csumCode(string);
    },

    previousTrack: function (subnetid, deviceid) {
        var fixcode = "\x2A\x53\x31\x50\x52\x45\x56\x0D";					// Fixed hexcode for *Z1PREV<CR>
        var string = sbus.formatStringHeader("\x13","\x19\x2E",subnetid,deviceid) + fixcode;
        sbus.csumCode(string);
    },
    nextTrack: function (subnetid, deviceid) {
        var fixcode = "\x2A\x53\x31\x4E\x45\x58\x54\x0D";					//
        var string = sbus.formatStringHeader("\x13","\x19\x2E",subnetid,deviceid) + fixcode;
        sbus.csumCode(string);
    },
    universalSwitch: function (subnetid, deviceid, switchNum, status) {
        var switchNo = String.fromCharCode(switchNum);
        var enable = String.fromCharCode(status);
        var string = sbus.formatStringHeader("\x0D","\xE0\x1C",subnetid,deviceid) + switchNo + enable;
        sbus.csumCode(string);
    },
    checkUniversalSwitch: function (subnetid, deviceid) {
        var string = sbus.formatStringHeader("\x0B","\xD9\x94",subnetid,deviceid);
        sbus.csumCode(string);
    },
    stop: function (subnetid, deviceid) {
        var fixcode = "\x2A\x53\x31\x53\x54\x4F\x50\x0D";
        var string = sbus.formatStringHeader("\x13","\x19\x2E",subnetid,deviceid) + fixcode;
        sbus.csumCode(string);
    },
    volume: function (subnetid, deviceid, level) {
        var fixcode = "\x2A\x5A\x31\x56\x4F\x4C" + level + "\x0D";
        var string = sbus.formatStringHeader("\x14","\x19\x2E",subnetid,deviceid) + fixcode;
        sbus.csumCode(string);
    },
    rgbw: function (subnetid, deviceid, red, green, blue, white, runtime) {
        var redhex = String.fromCharCode(red);                              //RED 0-255
        var greenhex = String.fromCharCode(green);                          //GREEN 0-255
        var bluehex = String.fromCharCode(blue);                            //BLUE 0-255
        var whitehex = String.fromCharCode(white);                          //WHITE 0-255
        var runhightime = String.fromCharCode((runtime >> 8) & 0xFF);		// High 8 bits running time. 0 - 3600s.
        var runlowtime = String.fromCharCode(runtime & 0xFF);

        var string = sbus.formatStringHeader("\x11","\xF0\x80",subnetid,deviceid)
            + redhex + greenhex + bluehex + whitehex + runhightime + runlowtime;
        sbus.csumCode(string);
    },
    LED_singleAdj: function (subnetid, deviceid, loopNo, loopLevel) {
        var loopNohex = String.fromCharCode(loopNo);					    // LoopNo.
        var LoopLevelhex = String.fromCharCode(loopLevel);					// LoopLevel.
        var string = sbus.formatStringHeader("\x0D","\x00\x31",subnetid,deviceid)
            + loopNohex + LoopLevelhex;
        sbus.csumCode(string);
    },

    processdata_relay: function (matches, totalChannels) {
        var subnetID = matches[2].charCodeAt(0);
        var deviceID = matches[3].charCodeAt(0);

        var channelStatus = new Array(matches);
        var mbstate = [0, 0];
        var value;
        var upperValue;

        for (var i = 1; i <= totalChannels; i++) {
            if (matches[i + 8].charCodeAt(0) <= 0) {
                channelStatus[i - 1] = 0;

            } else if (matches[i + 8].charCodeAt(0) >= 100) {
                channelStatus[i - 1] = 100;

            }
            else {
                channelStatus[i - 1] = Math.round(matches[i + 8].charCodeAt(0));
                // channelStatus[i - 1] = 1;
            }
        }
        for (var i = 0; i <= 7; i++) {
            value = (channelStatus[i] > 0) ? 1 : 0;
            mbstate[0] = mbstate[0] + ((value & 0x01) << i);
            // mbstate[0] = mbstate[0] + ((channelStatus[i] & 0x01) << i);
            if (totalChannels > 8 && i < totalChannels - 8) {
                upperValue = (channelStatus[i + 8] > 0) ? 1 : 0
                mbstate[1] = mbstate[1] + ((upperValue & 0x01) << i);
                // mbstate[1] = mbstate[1] + ((channelStatus[i+8] & 0x01) << i);
            }
        }
        eventsEmitter.emit("updatestatus", {type: "0", subnetID, deviceID, totalChannels, channelStatus});
    },



    processData: function (matchedString) {
        matchedString = sbus.pack(matchedString).substring(14);

        if (sbus.rgxZoneAudioStatusON.test(matchedString)) {
            //    rgxZoneAudioStatusON: /\xAA\xAA(.)(.)(.)(.)(.)\x19\x2F(.)(.)#Z(.*),(.*),SRC(.*),VOL(.*)\x0D(.*)/i,

            var matches = sbus.rgxZoneAudioStatusON.exec(matchedString);
            var subnetID = matches[2].charCodeAt(0);
            var deviceID = matches[3].charCodeAt(0);
            var Volume = ((((79 - matches[11]) / 79)) * 100).toFixed(0);
            var state = matches[9];

            if (matches[10] == 1) { var source = 'SD' }
            else if (matches[10] == 2) { var source = 'FTP'; }
            else if (matches[10] == 5) { var source = 'RADIO'; }
            else if (matches[10] == 6) { var source = 'AUDIO IN'; }
            else if (matches[10] == 3) { var source = 'Not sure'; }
            else if (matches[10] == 4) { var source = 'PA-in'; }
            eventsEmitter.emit("updatestatus", {subnetID, deviceID, state, source, Volume});

        }
        else if (sbus.relayresposnse.test(matchedString)) {
            ////  ch8relaystate: /\xAA\xAA(.)(.)(.)(.)(.)\x00\x32(.)(.)(.)(.)(.)(.)(.)(.)(.)/i,
            var matches = sbus.relayresposnse.exec(matchedString);
            var subnetID = matches[2].charCodeAt(0);
            var deviceID = matches[3].charCodeAt(0);
            var totalChannels = matches[11].charCodeAt(0);
            var no_of_channels = matches[11].charCodeAt(0);
            var mbstate = [];
            mbstate[0] = matches[12].charCodeAt(0);
            if (no_of_channels > 8) {
                mbstate[1] = (matches[13].charCodeAt(0) & 0x0F);
            }
            var channelStatus = [];

            for (var i = 0; i <= 7; i++) {								// use i=3(2ch), i=4(3ch),i=5(4ch),i=7(6ch),i=13(12ch)
                channelStatus[i] = ((matches[12].charCodeAt(0) >> i) & 0x01) * 100;
                if (i < 4 && no_of_channels == 12) {
                    channelStatus[i + 8] = ((matches[12 + 1].charCodeAt(0) >> i) & 0x01) * 100
                }
                else if (i < 7 && no_of_channels == 15) {
                    channelStatus[i + 8] = ((matches[12 + 1].charCodeAt(0) >> i) & 0x01) * 100
                }
            };
            eventsEmitter.emit("updatestatus", {subnetID, deviceID, totalChannels, channelStatus,type:"0"});
        }

        else if (sbus.relaystate.test(matchedString)) {
            //relaystate: /\xAA\xAA(.)(.)(.)(.)(.)\xEF\xFF(.)(.)(.)(.)(.)(.)(.)(.)(.)/i
            var matches = sbus.relaystate.exec(matchedString);
            var subnetID = matches[2].charCodeAt(0);
            var deviceID = matches[3].charCodeAt(0);
            var no_of_zones = matches[8].charCodeAt(0);
            var ofs = no_of_zones - 1;
            var totalChannels = matches[10 + ofs].charCodeAt(0);
            var mbstate = [];
            mbstate[0] = matches[11 + ofs].charCodeAt(0);
            if (totalChannels > 8) {
                mbstate[1] = (matches[12 + ofs].charCodeAt(0) & 0x0F);
            }

            var channelStatus = []
            for (var i = 0; i <= 7; i++) {										// use i=3(2ch), i=4(3ch),i=5(4ch),i=7(6ch),i=13(12ch)
                channelStatus[i] = ((matches[11 + ofs].charCodeAt(0) >> i) & 0x01) * 100;
                if (i <= 3 && totalChannels == 12) {
                    channelStatus[i + 8] = ((matches[12 + ofs].charCodeAt(0) >> i) & 0x01) * 100;
                }

                else if (i <= 6 && totalChannels == 15) {
                    channelStatus[i + 8] = ((matches[12 + ofs].charCodeAt(0) >> i) & 0x01) * 100;
                }
            }

            eventsEmitter.emit("updatestatus", {subnetID, deviceID, totalChannels, no_of_zones, channelStatus,type:"0"});

        }

        else if (sbus.broadcast4Z.test(matchedString)) {

            //broadcast4Z: /\xAA\xAA(.)(.)(.)(.)(.)\xDC\x22(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)/i
            var matches = sbus.broadcast4Z.exec(matchedString);
            var subnetID = matches[2].charCodeAt(0);
            var deviceID = matches[3].charCodeAt(0);
            var qty_contacts = matches[8].charCodeAt(0);
            var totalChannels = qty_contacts;
            var type_contacts = [matches[9].charCodeAt(0), matches[10].charCodeAt(0), matches[11].charCodeAt(0), matches[12].charCodeAt(0)]
            var contactstatus = [];
            var mbstate = [];
            mbstate[0] = 0
            contactstatus[0] = matches[13].charCodeAt(0);
            contactstatus[1] = matches[14].charCodeAt(0);
            contactstatus[2] = matches[15].charCodeAt(0);
            contactstatus[3] = matches[16].charCodeAt(0);
            for (var i = 0; i <= 3; i++) {										// use i=3(2ch), i=4(3ch),i=5(4ch),i=7(6ch),i=13(12ch)
                mbstate[0] = mbstate[0] + ((contactstatus[i] & 0x01) << i)
            }
            eventsEmitter.emit("updatestatus", {subnetID, deviceID, qty_contacts,totalChannels:4, contactstatus,type:"1"});
        }

        else if (sbus.Status4Z.test(matchedString)) {
            var matches = sbus.Status4Z.exec(matchedString);

            if (matches[8].charCodeAt(0) == 0xF8) {//success

                var channelStatus = new Array(4);
                var mbstate = [0, 0]
                //NB: response is inverted: 0 - connected, 1 - disconnected
                channelStatus[0] = (matches[14].charCodeAt(0) == 0) ? 1 : 0;
                channelStatus[1] = (matches[15].charCodeAt(0) == 0) ? 1 : 0;
                channelStatus[2] = (matches[16].charCodeAt(0) == 0) ? 1 : 0;
                channelStatus[3] = (matches[17].charCodeAt(0) == 0) ? 1 : 0;
                for (var i = 0; i < 4; i++) {
                    mbstate[0] = mbstate[0] + (channelStatus[i] << i);;
                }
                var subnetID = matches[2].charCodeAt(0);
                var deviceID = matches[3].charCodeAt(0);
                eventsEmitter.emit("updatestatus", {type:"1", subnetID, deviceID, "totalChannels":4, channelStatus});
            }
        }

        else if (sbus.SensorBaseStatus.test(matchedString)) {
            var matches = sbus.SensorBaseStatus.exec(matchedString);
            var indexConfig = { 64: [0, 1, 2, 3, 4, 5, 6], 184: [0, 1, 2, 3, 4, 5, 6] };
            var subnetID = matches[2].charCodeAt(0);
            var deviceID = matches[3].charCodeAt(0);
            var mbstate = [0, 0];
            var channelStatus = [];
            //64 - 9 in 1-254 255 253 252 251 250 249
            //184 - 5 IPIR-250 249 255 254 253 252 251
            var baseType = matches[5].charCodeAt(0)
            for (var i = 0; i <= 6; i++) {
                channelStatus[i] = (matches[8 + indexConfig[baseType][i]].charCodeAt(0) == 0) ? 0 : 1;
                mbstate[0] = mbstate[0] + ((channelStatus[i] & 0x01) << i);
            }
            eventsEmitter.emit("updatestatus", {subnetID, deviceID, totalChannels:7, channelStatus,type:"2"});
        }


        else if (sbus.rgx24ChannelStatus.test(matchedString)) {							// Test for Relay Channel Status feedback. Have 2,3,4,6,12 ch.
            var matches = sbus.rgx24ChannelStatus.exec(matchedString);
            sbus.processdata_relay(matches, 24);
        }

        else if (sbus.rgx15ChannelStatus.test(matchedString)) {							// Test for Relay Channel Status feedback. Have 2,3,4,6,12 ch.
            var matches = sbus.rgx15ChannelStatus.exec(matchedString);
            sbus.processdata_relay(matches, 15);
        }
        else if (sbus.rgx12ChannelStatus.test(matchedString)) {							// Test for Relay Channel Status feedback. Have 2,3,4,6,12 ch.
            var matches = sbus.rgx12ChannelStatus.exec(matchedString);
            sbus.processdata_relay(matches, 12);
        }
        else if (sbus.rgx8ChannelStatus.test(matchedString)) {							// Test for Relay Channel Status feedback. Have 2,3,4,6,12 ch.
            var matches = sbus.rgx8ChannelStatus.exec(matchedString);
            sbus.processdata_relay(matches, 8);
        }
        else if (sbus.rgx6ChannelStatus.test(matchedString)) {							// Test for Relay Channel Status feedback. Have 2,3,4,6,12 ch.
            var matches = sbus.rgx6ChannelStatus.exec(matchedString);
            sbus.processdata_relay(matches, 6);
        }
        else if (sbus.rgx4ChannelStatus.test(matchedString)) {							// Test for Relay Channel Status feedback. Have 2,3,4,6,12 ch.
            var matches = sbus.rgx4ChannelStatus.exec(matchedString);
            sbus.processdata_relay(matches, 4);
        }
        else if (sbus.rgx3ChannelStatus.test(matchedString)) {							// Test for Relay Channel Status feedback. Have 2,3,4,6,12 ch.
            var matches = sbus.rgx3ChannelStatus.exec(matchedString);
            sbus.processdata_relay(matches, 3);
        }
        else if (sbus.rgx2ChannelStatus.test(matchedString)) {							// Test for Relay Channel Status feedback. Have 2,3,4,6,12 ch.
            var matches = sbus.rgx2ChannelStatus.exec(matchedString);
            sbus.processdata_relay(matches, 2);
        }
    }
}

module.exports = {
    SetObjects: function (_udpServer, _eventsEmitter) {
        udpServer = _udpServer;
        eventsEmitter = _eventsEmitter;
    }
}

module.exports.sbus = sbus;